from typing import List, Optional, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, ConfigDict, field_validator
from datetime import datetime
import re


class MCPServerWorkflowBase(BaseModel):
    """Base schema for MCP Server Workflow"""
    workflow_id: UUID
    tool_name: str = Field(..., min_length=1, description="Name to expose as MCP tool (lowercase with underscores)")
    tool_description: str = Field(..., min_length=1, description="Description for the MCP tool")

    @field_validator('tool_name')
    @classmethod
    def validate_tool_name(cls, v: str) -> str:
        """Validate tool name format: lowercase, alphanumeric, underscores only"""
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Tool name must be lowercase with alphanumeric characters and underscores only')
        return v


class MCPServerWorkflowCreate(MCPServerWorkflowBase):
    """Schema for creating an MCP Server Workflow"""
    pass  # noqa: WPS420


class MCPServerWorkflowResponse(MCPServerWorkflowBase):
    """Schema for MCP Server Workflow response"""
    id: UUID
    mcp_server_id: UUID
    input_schema: Optional[Dict[str, Any]] = Field(None, description="Input schema extracted from chatInputNode (JSON Schema format)")
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MCPServerBase(BaseModel):
    """Base schema for MCP Server"""
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    is_active: int = Field(default=1, ge=0, le=1)


class MCPServerCreate(BaseModel):
    """Schema for creating an MCP Server"""
    name: str = Field(..., min_length=1, max_length=255)
    api_key: str = Field(..., min_length=32, description="API key for authentication (minimum 32 characters)")
    workflows: List[MCPServerWorkflowCreate] = Field(..., min_length=1, description="List of workflows to expose as tools")
    description: Optional[str] = None
    is_active: int = Field(default=1, ge=0, le=1)

    @field_validator('workflows')
    @classmethod
    def validate_unique_tool_names(cls, v: List[MCPServerWorkflowCreate]) -> List[MCPServerWorkflowCreate]:
        """Ensure tool names are unique within the workflows list"""
        tool_names = [wf.tool_name for wf in v]
        if len(tool_names) != len(set(tool_names)):
            raise ValueError('Tool names must be unique within the workflows list')
        return v


class MCPServerUpdate(BaseModel):
    """Schema for updating an MCP Server"""
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    api_key: Optional[str] = Field(None, min_length=32, description="API key for authentication (minimum 32 characters)")
    workflows: Optional[List[MCPServerWorkflowCreate]] = Field(None, min_length=1)
    description: Optional[str] = None
    is_active: Optional[int] = Field(None, ge=0, le=1)

    @field_validator('workflows')
    @classmethod
    def validate_unique_tool_names(cls, v: Optional[List[MCPServerWorkflowCreate]]) -> Optional[List[MCPServerWorkflowCreate]]:
        """Ensure tool names are unique within the workflows list"""
        if v is None:
            return v
        tool_names = [wf.tool_name for wf in v]
        if len(tool_names) != len(set(tool_names)):
            raise ValueError('Tool names must be unique within the workflows list')
        return v


class MCPServerResponse(MCPServerBase):
    """Schema for MCP Server response"""
    id: UUID
    url: Optional[str] = Field(None, description="MCP server URL (generated by backend)")
    api_key: str = Field(..., description="Masked API key (***)")
    workflows: List[MCPServerWorkflowResponse]
    is_deleted: int
    user_id: UUID
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)

